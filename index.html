<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Multicolor Square Pro</title>
<style>
:root{
--bg:#070a10;
--panel:rgba(16,20,30,.62);
--panel2:rgba(10,14,22,.72);
--line:rgba(255,255,255,.10);
--text:rgba(245,250,255,.92);
--muted:rgba(190,205,223,.70);
--a1:#6E7BFF;
--a2:#20D2A2;
--a3:#FF5CAD;
--a4:#FFC940;
--shadow:0 28px 90px rgba(0,0,0,.6);
--r:18px;
--mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;
--sans:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,Arial,"Noto Sans","Liberation Sans",sans-serif;
--ease:cubic-bezier(.2,.85,.2,1);
}
*{box-sizing:border-box}
html,body{height:100%}
body{
margin:0;
font-family:var(--sans);
color:var(--text);
background:var(--bg);
overflow:hidden;
position:relative;
}
#bgCanvas{
position:fixed;
inset:0;
z-index:-3;
}
body::before{
content:"";
position:fixed;
inset:-20%;
z-index:-2;
background:
radial-gradient(820px 620px at 12% 15%,rgba(110,123,255,.34),transparent 62%),
radial-gradient(820px 620px at 88% 20%,rgba(32,210,162,.22),transparent 64%),
radial-gradient(820px 620px at 50% 92%,rgba(255,92,173,.18),transparent 62%),
linear-gradient(-45deg,rgba(110,123,255,.15),rgba(32,210,162,.10),rgba(255,92,173,.10),rgba(110,123,255,.15));
background-size:160% 160%;
filter:saturate(1.2) contrast(1.06);
animation:bgMove 12s var(--ease) infinite alternate;
transform:translateZ(0);
}
@keyframes bgMove{
0%{background-position:0% 50%;transform:scale(1.02) rotate(-.15deg);}
100%{background-position:100% 50%;transform:scale(1.06) rotate(.15deg);}
}
body::after{
content:"";
position:fixed;
inset:0;
z-index:-1;
opacity:.26;
background-image:
repeating-linear-gradient(90deg,rgba(255,255,255,.06) 0 1px,transparent 1px 44px),
repeating-linear-gradient(180deg,rgba(255,255,255,.05) 0 1px,transparent 1px 44px),
repeating-linear-gradient(-45deg,rgba(110,123,255,0) 0 18px,rgba(110,123,255,.12) 18px 19px,rgba(110,123,255,0) 19px 38px);
background-size:44px 44px,44px 44px,160px 160px;
animation:gridFlow 26s linear infinite;
mask-image:radial-gradient(circle at 50% 40%,black 0 58%,transparent 80%);
pointer-events:none;
}
@keyframes gridFlow{
from{background-position:0 0,0 0,0 0;}
to{background-position:-1200px 0,0 -900px,700px 300px;}
}
@media (prefers-reduced-motion:reduce){
body::before,body::after,#bgCanvas{animation:none!important;}
}
.app{
height:100%;
display:grid;
grid-template-columns:380px 1fr;
gap:14px;
padding:14px;
}
@media (max-width:980px){
body{overflow:auto;}
.app{grid-template-columns:1fr;}
}
.panel{
border:1px solid var(--line);
border-radius:var(--r);
background:linear-gradient(180deg,var(--panel),var(--panel2));
box-shadow:var(--shadow);
backdrop-filter:blur(14px);
overflow:hidden;
}
.leftPanel{
display:flex;
flex-direction:column;
max-height:100%;
}
.pHead{
padding:14px 14px 10px;
border-bottom:1px solid rgba(255,255,255,.09);
display:flex;
align-items:center;
justify-content:space-between;
gap:12px;
flex-shrink:0;
}
.brand{
display:flex;
align-items:center;
gap:12px;
}
.logo{
width:36px;
height:36px;
border-radius:14px;
background:conic-gradient(from 180deg,var(--a1),var(--a2),var(--a3),var(--a1));
box-shadow:0 0 0 3px rgba(255,255,255,.06),0 20px 60px rgba(110,123,255,.18);
position:relative;
overflow:hidden;
animation:logoSpin 20s linear infinite;
}
@keyframes logoSpin{
from{transform:rotate(0deg);}
to{transform:rotate(360deg);}
}
.logo::after{
content:"";
position:absolute;
inset:-70%;
background:radial-gradient(circle at 30% 30%,rgba(255,255,255,.22),transparent 55%);
animation:sheen 3s var(--ease) infinite;
}
@keyframes sheen{
0%{transform:translate3d(-12%,-10%,0) rotate(8deg);opacity:.18;}
50%{transform:translate3d(12%,10%,0) rotate(18deg);opacity:.28;}
100%{transform:translate3d(-12%,-10%,0) rotate(8deg);opacity:.18;}
}
.name{
margin:0;
font-size:14px;
letter-spacing:2.6px;
text-transform:uppercase;
}
.mini{
margin-top:4px;
font-family:var(--mono);
font-size:12px;
color:var(--muted);
}
.tabs{
display:flex;
gap:6px;
padding:10px 14px;
border-bottom:1px solid rgba(255,255,255,.08);
flex-shrink:0;
overflow-x:auto;
}
.tab{
padding:8px 14px;
border-radius:12px;
background:rgba(255,255,255,.04);
border:1px solid rgba(255,255,255,.10);
cursor:pointer;
font-size:13px;
white-space:nowrap;
transition:all 200ms var(--ease);
position:relative;
overflow:hidden;
}
.tab::before{
content:"";
position:absolute;
inset:0;
background:linear-gradient(135deg,rgba(110,123,255,.2),rgba(32,210,162,.2));
opacity:0;
transition:opacity 200ms var(--ease);
}
.tab:hover{
background:rgba(255,255,255,.08);
border-color:rgba(255,255,255,.18);
transform:translateY(-1px);
}
.tab.active{
background:rgba(110,123,255,.16);
border-color:rgba(110,123,255,.40);
color:var(--text);
}
.tab.active::before{
opacity:1;
}
.pBody{
padding:12px 14px 14px;
display:grid;
gap:10px;
overflow-y:auto;
flex:1;
}
.pBody::-webkit-scrollbar{
width:8px;
}
.pBody::-webkit-scrollbar-track{
background:rgba(255,255,255,.04);
border-radius:10px;
}
.pBody::-webkit-scrollbar-thumb{
background:rgba(255,255,255,.14);
border-radius:10px;
}
.pBody::-webkit-scrollbar-thumb:hover{
background:rgba(255,255,255,.22);
}
.section{
display:none;
}
.section.active{
display:grid;
gap:10px;
animation:fadeIn 300ms var(--ease);
}
@keyframes fadeIn{
from{opacity:0;transform:translateY(8px);}
to{opacity:1;transform:translateY(0);}
}
.row{
display:grid;
grid-template-columns:1fr 1fr;
gap:10px;
}
.row1{
display:grid;
grid-template-columns:1fr;
gap:10px;
}
.field{
border:1px solid rgba(255,255,255,.12);
background:rgba(255,255,255,.04);
border-radius:14px;
padding:10px;
display:flex;
flex-direction:column;
gap:6px;
transition:all 200ms var(--ease);
}
.field:hover{
background:rgba(255,255,255,.06);
border-color:rgba(255,255,255,.18);
}
.lab{
font-family:var(--mono);
font-size:12px;
color:rgba(190,205,223,.70);
display:flex;
align-items:center;
justify-content:space-between;
gap:10px;
}
input[type="range"]{
width:100%;
}
input[type="color"]{
width:100%;
height:34px;
border-radius:12px;
border:1px solid rgba(255,255,255,.14);
background:transparent;
padding:0;
cursor:pointer;
}
input[type="text"],input[type="number"],select{
width:100%;
padding:8px 10px;
border-radius:10px;
border:1px solid rgba(255,255,255,.14);
background:rgba(255,255,255,.06);
color:var(--text);
font-family:var(--mono);
font-size:12px;
}
select,button{
font-family:inherit;
}
.btnRow{
display:flex;
gap:10px;
flex-wrap:wrap;
}
.btn{
border:1px solid rgba(110,123,255,.45);
background:rgba(110,123,255,.14);
color:var(--text);
padding:10px 12px;
border-radius:14px;
cursor:pointer;
font-size:13px;
user-select:none;
position:relative;
overflow:hidden;
transition:transform 200ms var(--ease),background 200ms var(--ease),border-color 200ms var(--ease);
}
.btn::before{
content:"";
position:absolute;
inset:0;
background:radial-gradient(circle at center,rgba(255,255,255,.15),transparent 70%);
opacity:0;
transition:opacity 200ms var(--ease);
}
.btn:hover{
transform:translateY(-1px);
background:rgba(110,123,255,.20);
border-color:rgba(32,210,162,.40);
}
.btn:hover::before{
opacity:1;
}
.btn:active{
transform:translateY(0) scale(.99);
}
.btn.ghost{
border-color:rgba(255,255,255,.14);
background:rgba(255,255,255,.04);
color:var(--muted);
}
.btn.ghost:hover{
background:rgba(255,255,255,.06);
color:var(--text);
border-color:rgba(255,255,255,.20);
}
.btn.small{
padding:6px 10px;
font-size:12px;
}
.toggle{
display:flex;
align-items:center;
justify-content:space-between;
gap:12px;
}
.sw{
width:44px;
height:26px;
border-radius:999px;
border:1px solid rgba(255,255,255,.16);
background:rgba(255,255,255,.06);
position:relative;
cursor:pointer;
flex:0 0 auto;
transition:background 200ms var(--ease);
}
.sw i{
position:absolute;
top:3px;
left:3px;
width:20px;
height:20px;
border-radius:999px;
background:rgba(245,250,255,.85);
box-shadow:0 12px 24px rgba(0,0,0,.25);
transition:transform 220ms var(--ease),background 220ms var(--ease);
}
.sw.on{
background:rgba(32,210,162,.14);
border-color:rgba(32,210,162,.35);
}
.sw.on i{
transform:translateX(18px);
background:rgba(32,210,162,.92);
}
.hint{
font-family:var(--mono);
font-size:12px;
color:rgba(190,205,223,.60);
padding-top:4px;
}
.stage{
border:1px solid var(--line);
border-radius:var(--r);
background:rgba(0,0,0,.16);
box-shadow:var(--shadow);
position:relative;
overflow:hidden;
min-height:520px;
}
.stageInner{
position:absolute;
inset:0;
display:grid;
place-items:center;
}
.canWrap{
position:relative;
transform:translateZ(0);
will-change:transform;
}
canvas.main{
display:block;
border-radius:14px;
background:#0b0f17;
box-shadow:0 26px 80px rgba(0,0,0,.55);
touch-action:none;
}
#gridOverlay,#vectorLayer,#smoothLayer{
position:absolute;
inset:0;
pointer-events:none;
}
.layerList{
max-height:200px;
overflow-y:auto;
border:1px solid rgba(255,255,255,.10);
border-radius:12px;
background:rgba(0,0,0,.20);
}
.layerItem{
padding:8px 10px;
border-bottom:1px solid rgba(255,255,255,.06);
display:flex;
align-items:center;
justify-content:space-between;
cursor:pointer;
transition:background 150ms var(--ease);
}
.layerItem:hover{
background:rgba(255,255,255,.06);
}
.layerItem.active{
background:rgba(110,123,255,.16);
border-left:3px solid var(--a1);
}
.layerItem:last-child{
border-bottom:none;
}
.layerName{
font-family:var(--mono);
font-size:12px;
}
.layerControls{
display:flex;
gap:6px;
}
.layerBtn{
padding:4px 8px;
border-radius:8px;
border:1px solid rgba(255,255,255,.12);
background:rgba(255,255,255,.04);
cursor:pointer;
font-size:11px;
transition:all 150ms var(--ease);
}
.layerBtn:hover{
background:rgba(255,255,255,.10);
}
.frameList{
display:flex;
gap:8px;
overflow-x:auto;
padding:8px;
border:1px solid rgba(255,255,255,.10);
border-radius:12px;
background:rgba(0,0,0,.20);
}
.frameThumb{
width:60px;
height:60px;
border:2px solid rgba(255,255,255,.14);
border-radius:10px;
background:rgba(0,0,0,.30);
cursor:pointer;
position:relative;
flex-shrink:0;
transition:all 200ms var(--ease);
overflow:hidden;
}
.frameThumb:hover{
border-color:rgba(32,210,162,.40);
transform:scale(1.05);
}
.frameThumb.active{
border-color:var(--a1);
box-shadow:0 0 0 2px rgba(110,123,255,.30);
}
.frameThumb canvas{
width:100%;
height:100%;
}
.frameNum{
position:absolute;
top:2px;
right:2px;
background:rgba(0,0,0,.70);
color:var(--text);
font-family:var(--mono);
font-size:10px;
padding:2px 4px;
border-radius:4px;
}
.paletteGrid{
display:grid;
grid-template-columns:repeat(5,1fr);
gap:8px;
}
.paletteItem{
aspect-ratio:1;
border-radius:10px;
border:2px solid rgba(255,255,255,.14);
cursor:pointer;
transition:all 200ms var(--ease);
position:relative;
overflow:hidden;
}
.paletteItem::before{
content:"";
position:absolute;
inset:0;
background:radial-gradient(circle at 30% 30%,rgba(255,255,255,.25),transparent 60%);
opacity:0;
transition:opacity 200ms var(--ease);
}
.paletteItem:hover{
transform:scale(1.1);
border-color:rgba(255,255,255,.40);
}
.paletteItem:hover::before{
opacity:1;
}
.paletteItem.selected{
border-color:var(--a1);
box-shadow:0 0 0 3px rgba(110,123,255,.30);
}
.stampGrid{
display:grid;
grid-template-columns:repeat(4,1fr);
gap:8px;
}
.stampItem{
aspect-ratio:1;
border-radius:10px;
border:2px solid rgba(255,255,255,.14);
background:rgba(255,255,255,.04);
cursor:pointer;
display:grid;
place-items:center;
font-size:24px;
transition:all 200ms var(--ease);
}
.stampItem:hover{
background:rgba(255,255,255,.08);
border-color:rgba(255,255,255,.30);
transform:scale(1.05);
}
.stampItem.active{
border-color:var(--a2);
background:rgba(32,210,162,.12);
}
.toast{
position:fixed;
right:14px;
bottom:14px;
z-index:50;
border:1px solid rgba(255,255,255,.12);
border-radius:16px;
background:rgba(10,14,22,.78);
backdrop-filter:blur(12px);
padding:10px 12px;
display:none;
box-shadow:0 20px 60px rgba(0,0,0,.45);
min-width:min(360px,calc(100vw - 28px));
}
.toast.show{
display:block;
animation:toastIn 220ms var(--ease) both;
}
@keyframes toastIn{
from{transform:translateY(10px);opacity:0;}
to{transform:translateY(0);opacity:1;}
}
.toast .t1{
font-size:13px;
}
.toast .t2{
margin-top:6px;
font-family:var(--mono);
font-size:12px;
color:rgba(190,205,223,.70);
}
.modal{
position:fixed;
inset:0;
z-index:100;
background:rgba(0,0,0,.70);
backdrop-filter:blur(8px);
display:none;
place-items:center;
padding:20px;
}
.modal.show{
display:grid;
animation:modalFade 250ms var(--ease);
}
@keyframes modalFade{
from{opacity:0;}
to{opacity:1;}
}
.modalContent{
background:linear-gradient(180deg,var(--panel),var(--panel2));
border:1px solid var(--line);
border-radius:var(--r);
padding:20px;
max-width:600px;
width:100%;
max-height:80vh;
overflow-y:auto;
box-shadow:var(--shadow);
animation:modalSlide 300ms var(--ease);
}
@keyframes modalSlide{
from{transform:translateY(20px);opacity:0;}
to{transform:translateY(0);opacity:1;}
}
.modalHeader{
display:flex;
justify-content:space-between;
align-items:center;
margin-bottom:16px;
padding-bottom:12px;
border-bottom:1px solid rgba(255,255,255,.10);
}
.modalTitle{
font-size:18px;
font-weight:600;
}
.modalClose{
width:32px;
height:32px;
border-radius:8px;
border:1px solid rgba(255,255,255,.14);
background:rgba(255,255,255,.04);
cursor:pointer;
display:grid;
place-items:center;
transition:all 200ms var(--ease);
}
.modalClose:hover{
background:rgba(255,255,255,.10);
transform:rotate(90deg);
}
.modalBody{
display:grid;
gap:14px;
}
.previewCanvas{
width:100%;
border-radius:12px;
border:1px solid rgba(255,255,255,.12);
background:rgba(0,0,0,.30);
}
.progressBar{
width:100%;
height:6px;
background:rgba(255,255,255,.10);
border-radius:999px;
overflow:hidden;
margin-top:8px;
}
.progressFill{
height:100%;
background:linear-gradient(90deg,var(--a1),var(--a2),var(--a3));
border-radius:999px;
transition:width 200ms var(--ease);
animation:progressPulse 2s var(--ease) infinite;
}
@keyframes progressPulse{
0%,100%{opacity:1;}
50%{opacity:.7;}
}
</style>
</head>
<body>
<canvas id="bgCanvas"></canvas>
<div class="app">
<aside class="panel leftPanel" aria-label="Settings">
<div class="pHead">
<div class="brand">
<div class="logo" aria-hidden="true"></div>
<div>
<h1 class="name">MULTICOLOR SQUARE</h1>
<div class="mini">pixel canvas pro</div>
</div>
</div>
<button class="btn ghost" id="newBtn" type="button">New</button>
</div>
<div class="tabs">
<div class="tab active" data-tab="draw">Draw</div>
<div class="tab" data-tab="layers">Layers</div>
<div class="tab" data-tab="anim">Animate</div>
<div class="tab" data-tab="palette">Palette</div>
<div class="tab" data-tab="effects">Effects</div>
<div class="tab" data-tab="tools">Tools</div>
</div>
<div class="pBody">
<div class="section active" data-section="draw">
<div class="row">
<div class="field">
<div class="lab"><span>Grid</span><span id="gridVal">48</span></div>
<input id="grid" type="range" min="16" max="160" value="48" step="1"/>
</div>
<div class="field">
<div class="lab"><span>Brush</span><span id="brushVal">1</span></div>
<input id="brush" type="range" min="1" max="12" value="1" step="1"/>
</div>
</div>
<div class="row">
<div class="field">
<div class="lab"><span>Color</span><span id="hexOut">#20D2A2</span></div>
<input id="color" type="color" value="#20D2A2"/>
</div>
<div class="field">
<div class="lab"><span>Zoom</span><span id="zoomVal">100%</span></div>
<input id="zoom" type="range" min="60" max="200" value="100" step="1"/>
</div>
</div>
<div class="field">
<div class="lab"><span>Mode</span></div>
<select id="drawMode">
<option value="pixel">Pixel Grid</option>
<option value="vector">Vector Lines</option>
<option value="smooth">Smooth Brush</option>
</select>
</div>
<div class="field">
<div class="toggle">
<div class="lab" style="margin:0;"><span>Rainbow</span></div>
<div class="sw" id="rb"><i></i></div>
</div>
<div class="toggle" style="margin-top:10px;">
<div class="lab" style="margin:0;"><span>Eraser</span></div>
<div class="sw" id="er"><i></i></div>
</div>
<div class="toggle" style="margin-top:10px;">
<div class="lab" style="margin:0;"><span>Grid lines</span></div>
<div class="sw on" id="gl"><i></i></div>
</div>
<div class="toggle" style="margin-top:10px;">
<div class="lab" style="margin:0;"><span>Symmetry</span></div>
<div class="sw" id="sym"><i></i></div>
</div>
</div>
<div class="field">
<div class="lab"><span>Symmetry Axis</span></div>
<select id="symAxis">
<option value="v">Vertical</option>
<option value="h">Horizontal</option>
<option value="b">Both</option>
<option value="r4">4-way Radial</option>
<option value="r8">8-way Radial</option>
</select>
</div>
<div class="btnRow">
<button class="btn ghost" id="undoBtn">Undo</button>
<button class="btn ghost" id="redoBtn">Redo</button>
<button class="btn ghost" id="clearBtn">Clear</button>
<button class="btn" id="saveBtn">Save PNG</button>
</div>
<div class="btnRow">
<button class="btn ghost" id="exportBtn">Export</button>
<button class="btn ghost" id="importBtn">Import</button>
<input id="fileIn" type="file" accept="application/json" style="display:none;">
</div>
<div class="hint">
Draw: LMB + move • Touch: finger • Hotkeys: E=eraser R=rainbow Z/Y=undo/redo
</div>
</div>
<div class="section" data-section="layers">
<div class="btnRow">
<button class="btn" id="addLayerBtn">Add Layer</button>
<button class="btn ghost" id="delLayerBtn">Delete</button>
<button class="btn ghost" id="mergeLayerBtn">Merge Down</button>
</div>
<div class="field">
<div class="lab"><span>Opacity</span><span id="layerOpVal">100%</span></div>
<input id="layerOp" type="range" min="0" max="100" value="100" step="1"/>
</div>
<div class="field">
<div class="lab"><span>Blend Mode</span></div>
<select id="blendMode">
<option value="normal">Normal</option>
<option value="multiply">Multiply</option>
<option value="screen">Screen</option>
<option value="overlay">Overlay</option>
<option value="add">Add</option>
</select>
</div>
<div class="layerList" id="layerList"></div>
<div class="hint">
Layers stack bottom-to-top • Click to select • Toggle eye to hide
</div>
</div>
<div class="section" data-section="anim">
<div class="row">
<div class="field">
<div class="lab"><span>FPS</span><span id="fpsVal">12</span></div>
<input id="fps" type="range" min="1" max="30" value="12" step="1"/>
</div>
<div class="field">
<div class="lab"><span>Frame</span><span id="frameNumVal">1</span></div>
</div>
</div>
<div class="btnRow">
<button class="btn" id="addFrameBtn">Add Frame</button>
<button class="btn ghost" id="delFrameBtn">Delete</button>
<button class="btn ghost" id="dupFrameBtn">Duplicate</button>
</div>
<div class="btnRow">
<button class="btn" id="playBtn">Play</button>
<button class="btn ghost" id="stopBtn">Stop</button>
</div>
<div class="frameList" id="frameList"></div>
<div class="btnRow">
<button class="btn" id="exportAnimBtn">Export Frames</button>
</div>
<div class="hint">
Create multiple frames • Play animation • Export as PNG sequence
</div>
</div>
<div class="section" data-section="palette">
<div class="btnRow">
<button class="btn" id="genPaletteBtn">Generate</button>
<button class="btn ghost" id="extractPaletteBtn">Extract</button>
<button class="btn ghost" id="savePaletteBtn">Save</button>
</div>
<div class="field">
<div class="lab"><span>Palette Type</span></div>
<select id="paletteType">
<option value="analogous">Analogous</option>
<option value="complementary">Complementary</option>
<option value="triadic">Triadic</option>
<option value="monochrome">Monochrome</option>
<option value="random">Random</option>
</select>
</div>
<div class="paletteGrid" id="paletteGrid"></div>
<div class="hint">
Click color to use • Generate harmonious palettes • Extract from canvas
</div>
</div>
<div class="section" data-section="effects">
<div class="btnRow">
<button class="btn" id="glowBtn">Glow</button>
<button class="btn ghost" id="blurBtn">Blur</button>
<button class="btn ghost" id="pixelateBtn">Pixelate</button>
</div>
<div class="btnRow">
<button class="btn ghost" id="invertBtn">Invert</button>
<button class="btn ghost" id="grayscaleBtn">Grayscale</button>
<button class="btn ghost" id="sepiaBtn">Sepia</button>
</div>
<div class="field">
<div class="lab"><span>Brightness</span><span id="brightVal">100%</span></div>
<input id="bright" type="range" min="50" max="200" value="100" step="1"/>
</div>
<div class="field">
<div class="lab"><span>Contrast</span><span id="contrastVal">100%</span></div>
<input id="contrast" type="range" min="50" max="200" value="100" step="1"/>
</div>
<div class="field">
<div class="lab"><span>Saturation</span><span id="satVal">100%</span></div>
<input id="sat" type="range" min="0" max="200" value="100" step="1"/>
</div>
<div class="btnRow">
<button class="btn" id="applyEffectBtn">Apply</button>
<button class="btn ghost" id="resetEffectBtn">Reset</button>
</div>
<div class="hint">
Apply effects to current layer • Changes are additive • Use Apply to commit
</div>
</div>
<div class="section" data-section="tools">
<div class="field">
<div class="lab"><span>Stamp Tool</span></div>
<div class="stampGrid">
<div class="stampItem" data-stamp="circle">●</div>
<div class="stampItem" data-stamp="square">■</div>
<div class="stampItem" data-stamp="triangle">▲</div>
<div class="stampItem" data-stamp="star">★</div>
<div class="stampItem" data-stamp="heart">♥</div>
<div class="stampItem" data-stamp="diamond">◆</div>
<div class="stampItem" data-stamp="cross">✚</div>
<div class="stampItem" data-stamp="spiral">@</div>
</div>
</div>
<div class="field">
<div class="lab"><span>Stamp Size</span><span id="stampSizeVal">5</span></div>
<input id="stampSize" type="range" min="3" max="20" value="5" step="1"/>
</div>
<div class="btnRow">
<button class="btn" id="fillBtn">Fill Bucket</button>
<button class="btn ghost" id="pickBtn">Color Picker</button>
<button class="btn ghost" id="lineBtn">Line Tool</button>
</div>
<div class="btnRow">
<button class="btn ghost" id="rectBtn">Rectangle</button>
<button class="btn ghost" id="circleBtn">Circle</button>
<button class="btn ghost" id="textBtn">Text</button>
</div>
<div class="field">
<div class="toggle">
<div class="lab" style="margin:0;"><span>Filled Shapes</span></div>
<div class="sw on" id="fillShapes"><i></i></div>
</div>
</div>
<div class="field">
<div class="lab"><span>Snapshot</span></div>
<div class="btnRow">
<button class="btn small" id="saveSnapBtn">Save</button>
<button class="btn ghost small" id="loadSnapBtn">Load</button>
<button class="btn ghost small" id="listSnapBtn">List</button>
</div>
</div>
<div class="hint">
Stamps • Fill • Shapes • Save snapshots for quick restore
</div>
</div>
</div>
</aside>
<section class="stage panel" aria-label="Canvas">
<div class="stageInner">
<div class="canWrap" id="canWrap">
<canvas id="paint" class="main"></canvas>
<canvas id="gridOverlay"></canvas>
<canvas id="vectorLayer"></canvas>
<canvas id="smoothLayer"></canvas>
</div>
</div>
</section>
</div>
<div class="toast" id="toast" role="status" aria-live="polite">
<div class="t1" id="t1">OK</div>
<div class="t2" id="t2">…</div>
</div>
<div class="modal" id="snapshotModal">
<div class="modalContent">
<div class="modalHeader">
<div class="modalTitle">Saved Snapshots</div>
<div class="modalClose" id="closeSnapModal">✕</div>
</div>
<div class="modalBody" id="snapshotList"></div>
</div>
</div>
<div class="modal" id="exportModal">
<div class="modalContent">
<div class="modalHeader">
<div class="modalTitle">Export Animation</div>
<div class="modalClose" id="closeExportModal">✕</div>
</div>
<div class="modalBody">
<div id="exportStatus">Preparing frames...</div>
<div class="progressBar">
<div class="progressFill" id="exportProgress" style="width:0%"></div>
</div>
</div>
</div>
</div>
<script>
(()=>{
const $=(s,r=document)=>r.querySelector(s);
const $$=(s,r=document)=>Array.from(r.querySelectorAll(s));
const clamp=(n,a,b)=>Math.max(a,Math.min(b,n));
const canvas=$('#paint');
const ctx=canvas.getContext('2d',{alpha:false,willReadFrequently:true});
const gridCanvas=$('#gridOverlay');
const gctx=gridCanvas.getContext('2d');
const vectorCanvas=$('#vectorLayer');
const vctx=vectorCanvas.getContext('2d');
const smoothCanvas=$('#smoothLayer');
const sctx=smoothCanvas.getContext('2d');
const bgCanvas=$('#bgCanvas');
const bctx=bgCanvas.getContext('2d');
const gridSlider=$('#grid');
const brushSlider=$('#brush');
const zoomSlider=$('#zoom');
const colorPicker=$('#color');
const drawModeSelect=$('#drawMode');
const gridVal=$('#gridVal');
const brushVal=$('#brushVal');
const zoomVal=$('#zoomVal');
const hexOut=$('#hexOut');
const rbSw=$('#rb');
const erSw=$('#er');
const glSw=$('#gl');
const symSw=$('#sym');
const symAxisSelect=$('#symAxis');
const newBtn=$('#newBtn');
const undoBtn=$('#undoBtn');
const redoBtn=$('#redoBtn');
const clearBtn=$('#clearBtn');
const saveBtn=$('#saveBtn');
const exportBtn=$('#exportBtn');
const importBtn=$('#importBtn');
const fileIn=$('#fileIn');
const canWrap=$('#canWrap');
const toastEl=$('#toast');
const t1=$('#t1');
const t2=$('#t2');
const layerOpSlider=$('#layerOp');
const layerOpVal=$('#layerOpVal');
const blendModeSelect=$('#blendMode');
const addLayerBtn=$('#addLayerBtn');
const delLayerBtn=$('#delLayerBtn');
const mergeLayerBtn=$('#mergeLayerBtn');
const layerListEl=$('#layerList');
const fpsSlider=$('#fps');
const fpsVal=$('#fpsVal');
const frameNumVal=$('#frameNumVal');
const addFrameBtn=$('#addFrameBtn');
const delFrameBtn=$('#delFrameBtn');
const dupFrameBtn=$('#dupFrameBtn');
const playBtn=$('#playBtn');
const stopBtn=$('#stopBtn');
const frameListEl=$('#frameList');
const exportAnimBtn=$('#exportAnimBtn');
const genPaletteBtn=$('#genPaletteBtn');
const extractPaletteBtn=$('#extractPaletteBtn');
const savePaletteBtn=$('#savePaletteBtn');
const paletteTypeSelect=$('#paletteType');
const paletteGridEl=$('#paletteGrid');
const glowBtn=$('#glowBtn');
const blurBtn=$('#blurBtn');
const pixelateBtn=$('#pixelateBtn');
const invertBtn=$('#invertBtn');
const grayscaleBtn=$('#grayscaleBtn');
const sepiaBtn=$('#sepiaBtn');
const brightSlider=$('#bright');
const brightVal=$('#brightVal');
const contrastSlider=$('#contrast');
const contrastVal=$('#contrastVal');
const satSlider=$('#sat');
const satVal=$('#satVal');
const applyEffectBtn=$('#applyEffectBtn');
const resetEffectBtn=$('#resetEffectBtn');
const fillBtn=$('#fillBtn');
const pickBtn=$('#pickBtn');
const lineBtn=$('#lineBtn');
const rectBtn=$('#rectBtn');
const circleBtn=$('#circleBtn');
const textBtn=$('#textBtn');
const fillShapesSw=$('#fillShapes');
const stampSizeSlider=$('#stampSize');
const stampSizeVal=$('#stampSizeVal');
const saveSnapBtn=$('#saveSnapBtn');
const loadSnapBtn=$('#loadSnapBtn');
const listSnapBtn=$('#listSnapBtn');
const snapshotModal=$('#snapshotModal');
const closeSnapModal=$('#closeSnapModal');
const snapshotListEl=$('#snapshotList');
const exportModal=$('#exportModal');
const closeExportModal=$('#closeExportModal');
const exportStatus=$('#exportStatus');
const exportProgress=$('#exportProgress');
let toastTimer=0;
function toast(a,b=''){
t1.textContent=a;
t2.textContent=b;
toastEl.classList.add('show');
clearTimeout(toastTimer);
toastTimer=setTimeout(()=>toastEl.classList.remove('show'),2200);
}
let N=+gridSlider.value;
let brush=+brushSlider.value;
let zoom=+zoomSlider.value/100;
let showGrid=true;
let rainbow=false;
let eraser=false;
let symmetry=false;
let symAxis='v';
let drawMode='pixel';
let activeTool='brush';
let fillShapes=true;
let stampShape='circle';
let stampSize=5;
const BG=0x0b0f17;
let layers=[{
id:Date.now(),
name:'Layer 1',
pixels:new Uint32Array(N*N),
opacity:1,
visible:true,
blend:'normal'
}];
layers[0].pixels.fill(BG);
let activeLayerIdx=0;
let frames=[{
id:Date.now(),
layers:JSON.parse(JSON.stringify(layers.map(l=>({
id:l.id,
name:l.name,
pixels:Array.from(l.pixels),
opacity:l.opacity,
visible:l.visible,
blend:l.blend
}))))
}];
let activeFrameIdx=0;
let animPlaying=false;
let animTimer=0;
let fps=12;
const undo=[];
const redo=[];
const MAX_STACK=60;
let drawing=false;
let lastCell=-1;
let currentAction=null;
let palette=['#20D2A2','#6E7BFF','#FF5CAD','#FFC940','#8B5CF6','#EC4899','#F59E0B','#10B981','#3B82F6','#EF4444'];
let effectState={brightness:100,contrast:100,saturation:100};
let tempEffectCanvas=null;
let snapshots=[];
let vectorPath=[];
let smoothPath=[];
let shapeStart=null;
function hexToRgbInt(hex){
const s=hex.replace('#','').trim();
const v=parseInt(s,16);
return v&0xFFFFFF;
}
function rgbIntToHex(v){
return '#'+(v>>>0).toString(16).padStart(6,'0').toUpperCase();
}
function rgbIntToRgb(v){
return{r:(v>>16)&0xFF,g:(v>>8)&0xFF,b:v&0xFF};
}
function rgbToRgbInt(r,g,b){
return((r&0xFF)<<16)|((g&0xFF)<<8)|(b&0xFF);
}
function hslToRgbInt(h,s,l){
h=((h%360)+360)%360;
const c=(1-Math.abs(2*l-1))*s;
const x=c*(1-Math.abs(((h/60)%2)-1));
const m=l-c/2;
let r=0,g=0,b=0;
if(h<60){r=c;g=x;b=0;}
else if(h<120){r=x;g=c;b=0;}
else if(h<180){r=0;g=c;b=x;}
else if(h<240){r=0;g=x;b=c;}
else if(h<300){r=x;g=0;b=c;}
else{r=c;g=0;b=x;}
const R=Math.round((r+m)*255);
const G=Math.round((g+m)*255);
const B=Math.round((b+m)*255);
return(R<<16)|(G<<8)|B;
}
function rgbToHsl(r,g,b){
r/=255;g/=255;b/=255;
const max=Math.max(r,g,b);
const min=Math.min(r,g,b);
let h,s,l=(max+min)/2;
if(max===min){
h=s=0;
}else{
const d=max-min;
s=l>.5?d/(2-max-min):d/(max+min);
switch(max){
case r:h=(g-b)/d+(g<b?6:0);break;
case g:h=(b-r)/d+2;break;
case b:h=(r-g)/d+4;break;
}
h/=6;
}
return{h:h*360,s,l};
}
function setSwitch(sw,on){
sw.classList.toggle('on',!!on);
}
function updateUI(){
gridVal.textContent=String(N);
brushVal.textContent=String(brush);
zoomVal.textContent=Math.round(zoom*100)+'%';
hexOut.textContent=colorPicker.value.toUpperCase();
setSwitch(rbSw,rainbow);
setSwitch(erSw,eraser);
setSwitch(glSw,showGrid);
setSwitch(symSw,symmetry);
setSwitch(fillShapesSw,fillShapes);
layerOpVal.textContent=Math.round(layers[activeLayerIdx].opacity*100)+'%';
layerOpSlider.value=String(layers[activeLayerIdx].opacity*100);
blendModeSelect.value=layers[activeLayerIdx].blend;
fpsVal.textContent=String(fps);
frameNumVal.textContent=`${activeFrameIdx+1}/${frames.length}`;
brightVal.textContent=effectState.brightness+'%';
contrastVal.textContent=effectState.contrast+'%';
satVal.textContent=effectState.saturation+'%';
stampSizeVal.textContent=String(stampSize);
}
function calcCanvasSize(){
const stage=$('.stage');
const r=stage.getBoundingClientRect();
const pad=26;
const size=Math.max(280,Math.min(r.width-pad,r.height-pad));
return Math.floor(size);
}
function setupCanvases(){
const size=calcCanvasSize();
const dpr=Math.max(1,Math.min(2,window.devicePixelRatio||1));
canvas.width=Math.floor(size*dpr);
canvas.height=Math.floor(size*dpr);
canvas.style.width=size+'px';
canvas.style.height=size+'px';
gridCanvas.width=canvas.width;
gridCanvas.height=canvas.height;
gridCanvas.style.width=canvas.style.width;
gridCanvas.style.height=canvas.style.height;
vectorCanvas.width=canvas.width;
vectorCanvas.height=canvas.height;
vectorCanvas.style.width=canvas.style.width;
vectorCanvas.style.height=canvas.style.height;
smoothCanvas.width=canvas.width;
smoothCanvas.height=canvas.height;
smoothCanvas.style.width=canvas.style.width;
smoothCanvas.style.height=canvas.style.height;
ctx.setTransform(dpr,0,0,dpr,0,0);
gctx.setTransform(dpr,0,0,dpr,0,0);
vctx.setTransform(dpr,0,0,dpr,0,0);
sctx.setTransform(dpr,0,0,dpr,0,0);
canWrap.style.transform=`scale(${zoom})`;
drawAll();
drawGrid();
}
function cellSizePx(){
const size=parseFloat(canvas.style.width)||600;
return size/N;
}
function drawAll(){
const size=parseFloat(canvas.style.width)||600;
const cs=size/N;
ctx.fillStyle='#'+BG.toString(16).padStart(6,'0');
ctx.fillRect(0,0,size,size);
ctx.save();
if(tempEffectCanvas){
ctx.filter=`brightness(${effectState.brightness}%) contrast(${effectState.contrast}%) saturate(${effectState.saturation}%)`;
}
for(let li=0;li<layers.length;li++){
const layer=layers[li];
if(!layer.visible)continue;
ctx.globalAlpha=layer.opacity;
ctx.globalCompositeOperation=layer.blend==='normal'?'source-over':layer.blend;
for(let y=0;y<N;y++){
for(let x=0;x<N;x++){
const idx=y*N+x;
const col=layer.pixels[idx];
if(col===BG)continue;
ctx.fillStyle='#'+(col>>>0).toString(16).padStart(6,'0');
ctx.fillRect(x*cs,y*cs,cs,cs);
}
}
}
ctx.restore();
ctx.globalAlpha=1;
ctx.globalCompositeOperation='source-over';
}
function drawGrid(){
const size=parseFloat(gridCanvas.style.width)||600;
const cs=size/N;
gctx.clearRect(0,0,size,size);
if(!showGrid||drawMode!=='pixel')return;
gctx.globalAlpha=0.55;
gctx.lineWidth=1;
gctx.strokeStyle='rgba(255,255,255,.10)';
let step=1;
if(N>=96)step=2;
if(N>=128)step=4;
gctx.beginPath();
for(let i=0;i<=N;i+=step){
const p=i*cs;
gctx.moveTo(p,0);gctx.lineTo(p,size);
gctx.moveTo(0,p);gctx.lineTo(size,p);
}
gctx.stroke();
gctx.globalAlpha=1;
}
function paintCell(x,y,col){
if(x<0||y<0||x>=N||y>=N)return;
const idx=y*N+x;
const layer=layers[activeLayerIdx];
const prev=layer.pixels[idx];
if(prev===col)return;
if(currentAction){
if(!currentAction.seen.has(idx)){
currentAction.seen.add(idx);
currentAction.idxs.push(idx);
currentAction.prev.push(prev);
currentAction.next.push(col);
currentAction.layerIdx=activeLayerIdx;
}
}
layer.pixels[idx]=col;
const size=parseFloat(canvas.style.width)||600;
const cs=size/N;
ctx.save();
ctx.globalAlpha=layer.opacity;
ctx.globalCompositeOperation=layer.blend==='normal'?'source-over':layer.blend;
ctx.fillStyle='#'+(col>>>0).toString(16).padStart(6,'0');
ctx.fillRect(x*cs,y*cs,cs,cs);
ctx.restore();
}
function paintBrush(cx,cy){
const half=Math.floor(brush/2);
const base=eraser?BG:hexToRgbInt(colorPicker.value);
const t=performance.now()*0.001;
for(let dy=-half;dy<-half+brush;dy++){
for(let dx=-half;dx<-half+brush;dx++){
const x=cx+dx;
const y=cy+dy;
let col=base;
if(rainbow&&!eraser){
const hue=(t*90+(x*9)+(y*7))%360;
col=hslToRgbInt(hue,1.0,0.55);
}
paintCell(x,y,col);
if(symmetry){
applySymmetry(x,y,col);
}
}
}
}
function applySymmetry(x,y,col){
const cx=Math.floor(N/2);
const cy=Math.floor(N/2);
if(symAxis==='v'){
const sx=N-1-x;
paintCell(sx,y,col);
}else if(symAxis==='h'){
const sy=N-1-y;
paintCell(x,sy,col);
}else if(symAxis==='b'){
const sx=N-1-x;
const sy=N-1-y;
paintCell(sx,y,col);
paintCell(x,sy,col);
paintCell(sx,sy,col);
}else if(symAxis==='r4'){
const dx=x-cx;
const dy=y-cy;
paintCell(cx-dx,cy+dy,col);
paintCell(cx+dy,cy+dx,col);
paintCell(cx-dy,cy-dx,col);
}else if(symAxis==='r8'){
const dx=x-cx;
const dy=y-cy;
paintCell(cx-dx,cy+dy,col);
paintCell(cx+dy,cy+dx,col);
paintCell(cx-dy,cy-dx,col);
paintCell(cx-dx,cy-dy,col);
paintCell(cx+dx,cy-dy,col);
paintCell(cx-dy,cy+dx,col);
paintCell(cx+dy,cy-dx,col);
}
}
function posToCell(e){
const rect=canvas.getBoundingClientRect();
const size=rect.width;
const cs=size/N;
const x=Math.floor((e.clientX-rect.left)/cs);
const y=Math.floor((e.clientY-rect.top)/cs);
return{x,y};
}
function posToCanvas(e){
const rect=canvas.getBoundingClientRect();
return{
x:e.clientX-rect.left,
y:e.clientY-rect.top
};
}
function beginStroke(){
currentAction={idxs:[],prev:[],next:[],seen:new Set(),layerIdx:activeLayerIdx};
}
function endStroke(){
if(!currentAction)return;
if(currentAction.idxs.length){
undo.push({
idxs:currentAction.idxs,
prev:currentAction.prev,
next:currentAction.next,
layerIdx:currentAction.layerIdx
});
if(undo.length>MAX_STACK)undo.shift();
redo.length=0;
}
currentAction=null;
}
function doUndo(){
const a=undo.pop();
if(!a)return;
const layer=layers[a.layerIdx];
for(let i=0;i<a.idxs.length;i++){
layer.pixels[a.idxs[i]]=a.prev[i];
}
redo.push(a);
drawAll();
toast('Undo',`${a.idxs.length} cells`);
}
function doRedo(){
const a=redo.pop();
if(!a)return;
const layer=layers[a.layerIdx];
for(let i=0;i<a.idxs.length;i++){
layer.pixels[a.idxs[i]]=a.next[i];
}
undo.push(a);
drawAll();
toast('Redo',`${a.idxs.length} cells`);
}
function clearAll(){
const layer=layers[activeLayerIdx];
const prev=Array.from(layer.pixels);
layer.pixels.fill(BG);
drawAll();
undo.push({
idxs:prev.map((_,i)=>i),
prev:prev,
next:Array(prev.length).fill(BG),
layerIdx:activeLayerIdx
});
if(undo.length>MAX_STACK)undo.shift();
redo.length=0;
toast('Clear','Layer cleared');
}
function newCanvas(){
undo.length=0;
redo.length=0;
layers=[{
id:Date.now(),
name:'Layer 1',
pixels:new Uint32Array(N*N),
opacity:1,
visible:true,
blend:'normal'
}];
layers[0].pixels.fill(BG);
activeLayerIdx=0;
frames=[{
id:Date.now(),
layers:JSON.parse(JSON.stringify(layers.map(l=>({
id:l.id,
name:l.name,
pixels:Array.from(l.pixels),
opacity:l.opacity,
visible:l.visible,
blend:l.blend
}))))
}];
activeFrameIdx=0;
drawAll();
drawGrid();
updateLayerList();
updateFrameList();
toast('New',`${N}×${N}`);
}
function savePNG(){
const cellPx=20;
const outSize=N*cellPx;
const off=document.createElement('canvas');
off.width=outSize;
off.height=outSize;
const o=off.getContext('2d',{alpha:false});
o.fillStyle='#'+BG.toString(16).padStart(6,'0');
o.fillRect(0,0,outSize,outSize);
for(let li=0;li<layers.length;li++){
const layer=layers[li];
if(!layer.visible)continue;
o.globalAlpha=layer.opacity;
o.globalCompositeOperation=layer.blend==='normal'?'source-over':layer.blend;
for(let y=0;y<N;y++){
for(let x=0;x<N;x++){
const idx=y*N+x;
const col=layer.pixels[idx];
if(col===BG)continue;
o.fillStyle='#'+(col>>>0).toString(16).padStart(6,'0');
o.fillRect(x*cellPx,y*cellPx,cellPx,cellPx);
}
}
}
o.globalAlpha=1;
o.globalCompositeOperation='source-over';
const url=off.toDataURL('image/png');
const a=document.createElement('a');
a.href=url;
a.download=`multicolor-square_${N}x${N}.png`;
a.click();
toast('Saved',a.download);
}
function exportJSON(){
const payload={
app:'Multicolor Square Pro',
v:2,
N,
BG,
layers:layers.map(l=>({
id:l.id,
name:l.name,
pixels:Array.from(l.pixels),
opacity:l.opacity,
visible:l.visible,
blend:l.blend
})),
frames:frames,
activeLayerIdx,
activeFrameIdx
};
const blob=new Blob([JSON.stringify(payload)],{type:'application/json'});
const url=URL.createObjectURL(blob);
const a=document.createElement('a');
a.href=url;
a.download=`multicolor-square_${N}x${N}.json`;
a.click();
URL.revokeObjectURL(url);
toast('Export',a.download);
}
async function importJSONFile(file){
try{
const text=await file.text();
const data=JSON.parse(text);
if(!data||!data.app||!Number.isFinite(data.N)){
toast('Import','Invalid file');
return;
}
N=clamp(data.N|0,16,160);
gridSlider.value=String(N);
if(data.v===2&&data.layers){
layers=data.layers.map(l=>({
id:l.id||Date.now(),
name:l.name||'Layer',
pixels:new Uint32Array(l.pixels),
opacity:l.opacity??1,
visible:l.visible??true,
blend:l.blend||'normal'
}));
activeLayerIdx=data.activeLayerIdx||0;
if(data.frames){
frames=data.frames;
activeFrameIdx=data.activeFrameIdx||0;
}else{
frames=[{
id:Date.now(),
layers:JSON.parse(JSON.stringify(layers.map(l=>({
id:l.id,
name:l.name,
pixels:Array.from(l.pixels),
opacity:l.opacity,
visible:l.visible,
blend:l.blend
}))))
}];
activeFrameIdx=0;
}
}else{
layers=[{
id:Date.now(),
name:'Layer 1',
pixels:new Uint32Array(N*N),
opacity:1,
visible:true,
blend:'normal'
}];
const arr=data.pixels||[];
for(let i=0;i<layers[0].pixels.length;i++){
layers[0].pixels[i]=(arr[i]>>>0)&0xFFFFFF;
}
activeLayerIdx=0;
frames=[{
id:Date.now(),
layers:JSON.parse(JSON.stringify(layers.map(l=>({
id:l.id,
name:l.name,
pixels:Array.from(l.pixels),
opacity:l.opacity,
visible:l.visible,
blend:l.blend
}))))
}];
activeFrameIdx=0;
}
undo.length=0;
redo.length=0;
updateUI();
setupCanvases();
updateLayerList();
updateFrameList();
toast('Import',`${N}×${N}`);
}catch(e){
toast('Import','Error');
}
}
canvas.addEventListener('pointerdown',(e)=>{
if(drawMode==='pixel'&&activeTool==='brush'){
canvas.setPointerCapture(e.pointerId);
drawing=true;
lastCell=-1;
beginStroke();
const{x,y}=posToCell(e);
const cell=y*N+x;
lastCell=cell;
paintBrush(x,y);
}else if(drawMode==='vector'&&activeTool==='brush'){
canvas.setPointerCapture(e.pointerId);
drawing=true;
vectorPath=[];
const pos=posToCanvas(e);
vectorPath.push({x:pos.x,y:pos.y});
}else if(drawMode==='smooth'&&activeTool==='brush'){
canvas.setPointerCapture(e.pointerId);
drawing=true;
smoothPath=[];
const pos=posToCanvas(e);
smoothPath.push({x:pos.x,y:pos.y});
}else if(activeTool==='fill'){
const{x,y}=posToCell(e);
floodFill(x,y);
}else if(activeTool==='pick'){
const{x,y}=posToCell(e);
if(x>=0&&y>=0&&x<N&&y<N){
const idx=y*N+x;
const col=layers[activeLayerIdx].pixels[idx];
colorPicker.value=rgbIntToHex(col);
hexOut.textContent=colorPicker.value.toUpperCase();
toast('Picked',colorPicker.value);
}
activeTool='brush';
updateToolButtons();
}else if(activeTool==='line'||activeTool==='rect'||activeTool==='circle'){
canvas.setPointerCapture(e.pointerId);
drawing=true;
const{x,y}=posToCell(e);
shapeStart={x,y};
}else if(activeTool==='stamp'){
const{x,y}=posToCell(e);
drawStamp(x,y);
}
});
canvas.addEventListener('pointermove',(e)=>{
if(!drawing)return;
if(drawMode==='pixel'&&activeTool==='brush'){
const{x,y}=posToCell(e);
const cell=y*N+x;
if(cell===lastCell)return;
lastCell=cell;
paintBrush(x,y);
}else if(drawMode==='vector'&&activeTool==='brush'){
const pos=posToCanvas(e);
vectorPath.push({x:pos.x,y:pos.y});
drawVectorPath();
}else if(drawMode==='smooth'&&activeTool==='brush'){
const pos=posToCanvas(e);
smoothPath.push({x:pos.x,y:pos.y});
drawSmoothPath();
}else if(activeTool==='line'||activeTool==='rect'||activeTool==='circle'){
const{x,y}=posToCell(e);
drawShapePreview(shapeStart,{x,y});
}
});
const end=()=>{
if(!drawing)return;
drawing=false;
lastCell=-1;
if(drawMode==='pixel'&&activeTool==='brush'){
endStroke();
}else if(drawMode==='vector'&&activeTool==='brush'){
commitVectorPath();
vectorPath=[];
vctx.clearRect(0,0,vectorCanvas.width,vectorCanvas.height);
}else if(drawMode==='smooth'&&activeTool==='brush'){
commitSmoothPath();
smoothPath=[];
sctx.clearRect(0,0,smoothCanvas.width,smoothCanvas.height);
}else if(activeTool==='line'||activeTool==='rect'||activeTool==='circle'){
if(shapeStart){
const rect=canvas.getBoundingClientRect();
const size=rect.width;
const cs=size/N;
const x=Math.floor((event.clientX-rect.left)/cs);
const y=Math.floor((event.clientY-rect.top)/cs);
commitShape(shapeStart,{x,y});
shapeStart=null;
gctx.clearRect(0,0,gridCanvas.width,gridCanvas.height);
drawGrid();
}
}
};
canvas.addEventListener('pointerup',end);
canvas.addEventListener('pointercancel',end);
function drawVectorPath(){
const size=parseFloat(vectorCanvas.style.width)||600;
vctx.clearRect(0,0,size,size);
if(vectorPath.length<2)return;
vctx.strokeStyle=eraser?'#0b0f17':colorPicker.value;
vctx.lineWidth=brush*2;
vctx.lineCap='round';
vctx.lineJoin='round';
vctx.beginPath();
vctx.moveTo(vectorPath[0].x,vectorPath[0].y);
for(let i=1;i<vectorPath.length;i++){
vctx.lineTo(vectorPath[i].x,vectorPath[i].y);
}
vctx.stroke();
}
function commitVectorPath(){
if(vectorPath.length<2)return;
const size=parseFloat(canvas.style.width)||600;
const cs=size/N;
const layer=layers[activeLayerIdx];
const col=eraser?BG:hexToRgbInt(colorPicker.value);
beginStroke();
for(let i=1;i<vectorPath.length;i++){
const x0=vectorPath[i-1].x;
const y0=vectorPath[i-1].y;
const x1=vectorPath[i].x;
const y1=vectorPath[i].y;
bresenhamLine(x0,y0,x1,y1,(px,py)=>{
const cx=Math.floor(px/cs);
const cy=Math.floor(py/cs);
paintCell(cx,cy,col);
});
}
endStroke();
drawAll();
}
function bresenhamLine(x0,y0,x1,y1,plot){
x0=Math.round(x0);
y0=Math.round(y0);
x1=Math.round(x1);
y1=Math.round(y1);
const dx=Math.abs(x1-x0);
const dy=Math.abs(y1-y0);
const sx=x0<x1?1:-1;
const sy=y0<y1?1:-1;
let err=dx-dy;
while(true){
plot(x0,y0);
if(x0===x1&&y0===y1)break;
const e2=2*err;
if(e2>-dy){
err-=dy;
x0+=sx;
}
if(e2<dx){
err+=dx;
y0+=sy;
}
}
}
function drawSmoothPath(){
const size=parseFloat(smoothCanvas.style.width)||600;
sctx.clearRect(0,0,size,size);
if(smoothPath.length<2)return;
sctx.strokeStyle=eraser?'#0b0f17':colorPicker.value;
sctx.lineWidth=brush*3;
sctx.lineCap='round';
sctx.lineJoin='round';
sctx.shadowBlur=brush*2;
sctx.shadowColor=eraser?'#0b0f17':colorPicker.value;
sctx.beginPath();
sctx.moveTo(smoothPath[0].x,smoothPath[0].y);
for(let i=1;i<smoothPath.length;i++){
const xc=(smoothPath[i].x+smoothPath[i-1].x)/2;
const yc=(smoothPath[i].y+smoothPath[i-1].y)/2;
sctx.quadraticCurveTo(smoothPath[i-1].x,smoothPath[i-1].y,xc,yc);
}
sctx.stroke();
sctx.shadowBlur=0;
}
function commitSmoothPath(){
if(smoothPath.length<2)return;
const tempCanvas=document.createElement('canvas');
tempCanvas.width=canvas.width;
tempCanvas.height=canvas.height;
const tctx=tempCanvas.getContext('2d');
const size=parseFloat(canvas.style.width)||600;
const dpr=Math.max(1,Math.min(2,window.devicePixelRatio||1));
tctx.setTransform(dpr,0,0,dpr,0,0);
tctx.strokeStyle=eraser?'#0b0f17':colorPicker.value;
tctx.lineWidth=brush*3;
tctx.lineCap='round';
tctx.lineJoin='round';
tctx.shadowBlur=brush*2;
tctx.shadowColor=eraser?'#0b0f17':colorPicker.value;
tctx.beginPath();
tctx.moveTo(smoothPath[0].x,smoothPath[0].y);
for(let i=1;i<smoothPath.length;i++){
const xc=(smoothPath[i].x+smoothPath[i-1].x)/2;
const yc=(smoothPath[i].y+smoothPath[i-1].y)/2;
tctx.quadraticCurveTo(smoothPath[i-1].x,smoothPath[i-1].y,xc,yc);
}
tctx.stroke();
const imgData=tctx.getImageData(0,0,tempCanvas.width,tempCanvas.height);
const cs=size/N;
const layer=layers[activeLayerIdx];
const col=eraser?BG:hexToRgbInt(colorPicker.value);
beginStroke();
for(let py=0;py<imgData.height;py+=dpr){
for(let px=0;px<imgData.width;px+=dpr){
const i=(py*imgData.width+px)*4;
const a=imgData.data[i+3];
if(a>128){
const cx=Math.floor((px/dpr)/cs);
const cy=Math.floor((py/dpr)/cs);
paintCell(cx,cy,col);
}
}
}
endStroke();
drawAll();
}
function floodFill(sx,sy){
if(sx<0||sy<0||sx>=N||sy>=N)return;
const layer=layers[activeLayerIdx];
const target=layer.pixels[sy*N+sx];
const replacement=eraser?BG:hexToRgbInt(colorPicker.value);
if(target===replacement)return;
beginStroke();
const queue=[{x:sx,y:sy}];
const visited=new Set();
visited.add(sy*N+sx);
while(queue.length){
const{x,y}=queue.shift();
paintCell(x,y,replacement);
const dirs=[{x:x-1,y},{x:x+1,y},{x,y:y-1},{x,y:y+1}];
for(const d of dirs){
if(d.x<0||d.y<0||d.x>=N||d.y>=N)continue;
const idx=d.y*N+d.x;
if(visited.has(idx))continue;
if(layer.pixels[idx]===target){
visited.add(idx);
queue.push(d);
}
}
}
endStroke();
drawAll();
toast('Fill','Area filled');
}
function drawShapePreview(start,end){
if(!start)return;
const size=parseFloat(gridCanvas.style.width)||600;
gctx.clearRect(0,0,size,size);
drawGrid();
const cs=size/N;
gctx.strokeStyle=colorPicker.value;
gctx.lineWidth=2;
gctx.fillStyle=colorPicker.value;
gctx.globalAlpha=0.5;
if(activeTool==='line'){
gctx.beginPath();
gctx.moveTo(start.x*cs+cs/2,start.y*cs+cs/2);
gctx.lineTo(end.x*cs+cs/2,end.y*cs+cs/2);
gctx.stroke();
}else if(activeTool==='rect'){
const x=Math.min(start.x,end.x)*cs;
const y=Math.min(start.y,end.y)*cs;
const w=Math.abs(end.x-start.x+1)*cs;
const h=Math.abs(end.y-start.y+1)*cs;
if(fillShapes){
gctx.fillRect(x,y,w,h);
}else{
gctx.strokeRect(x,y,w,h);
}
}else if(activeTool==='circle'){
const cx=(start.x+end.x)/2*cs+cs/2;
const cy=(start.y+end.y)/2*cs+cs/2;
const rx=Math.abs(end.x-start.x+1)*cs/2;
const ry=Math.abs(end.y-start.y+1)*cs/2;
gctx.beginPath();
gctx.ellipse(cx,cy,rx,ry,0,0,Math.PI*2);
if(fillShapes){
gctx.fill();
}else{
gctx.stroke();
}
}
gctx.globalAlpha=1;
}
function commitShape(start,end){
if(!start)return;
const col=eraser?BG:hexToRgbInt(colorPicker.value);
beginStroke();
if(activeTool==='line'){
const x0=start.x;
const y0=start.y;
const x1=end.x;
const y1=end.y;
bresenhamLineCell(x0,y0,x1,y1,(x,y)=>{
paintCell(x,y,col);
});
}else if(activeTool==='rect'){
const x0=Math.min(start.x,end.x);
const y0=Math.min(start.y,end.y);
const x1=Math.max(start.x,end.x);
const y1=Math.max(start.y,end.y);
if(fillShapes){
for(let y=y0;y<=y1;y++){
for(let x=x0;x<=x1;x++){
paintCell(x,y,col);
}
}
}else{
for(let x=x0;x<=x1;x++){
paintCell(x,y0,col);
paintCell(x,y1,col);
}
for(let y=y0;y<=y1;y++){
paintCell(x0,y,col);
paintCell(x1,y,col);
}
}
}else if(activeTool==='circle'){
const cx=(start.x+end.x)/2;
const cy=(start.y+end.y)/2;
const rx=Math.abs(end.x-start.x+1)/2;
const ry=Math.abs(end.y-start.y+1)/2;
if(fillShapes){
for(let y=Math.floor(cy-ry);y<=Math.ceil(cy+ry);y++){
for(let x=Math.floor(cx-rx);x<=Math.ceil(cx+rx);x++){
const dx=(x-cx)/rx;
const dy=(y-cy)/ry;
if(dx*dx+dy*dy<=1){
paintCell(x,y,col);
}
}
}
}else{
bresenhamEllipse(cx,cy,rx,ry,(x,y)=>{
paintCell(x,y,col);
});
}
}
endStroke();
drawAll();
activeTool='brush';
updateToolButtons();
}
function bresenhamLineCell(x0,y0,x1,y1,plot){
const dx=Math.abs(x1-x0);
const dy=Math.abs(y1-y0);
const sx=x0<x1?1:-1;
const sy=y0<y1?1:-1;
let err=dx-dy;
while(true){
plot(x0,y0);
if(x0===x1&&y0===y1)break;
const e2=2*err;
if(e2>-dy){
err-=dy;
x0+=sx;
}
if(e2<dx){
err+=dx;
y0+=sy;
}
}
}
function bresenhamEllipse(cx,cy,rx,ry,plot){
rx=Math.round(rx);
ry=Math.round(ry);
let x=0;
let y=ry;
let rx2=rx*rx;
let ry2=ry*ry;
let twoRx2=2*rx2;
let twoRy2=2*ry2;
let p=Math.round(ry2-(rx2*ry)+(0.25*rx2));
let px=0;
let py=twoRx2*y;
while(px<py){
plot(Math.round(cx+x),Math.round(cy+y));
plot(Math.round(cx-x),Math.round(cy+y));
plot(Math.round(cx+x),Math.round(cy-y));
plot(Math.round(cx-x),Math.round(cy-y));
x++;
px+=twoRy2;
if(p<0){
p+=ry2+px;
}else{
y--;
py-=twoRx2;
p+=ry2+px-py;
}
}
p=Math.round(ry2*(x+0.5)*(x+0.5)+rx2*(y-1)*(y-1)-rx2*ry2);
while(y>=0){
plot(Math.round(cx+x),Math.round(cy+y));
plot(Math.round(cx-x),Math.round(cy+y));
plot(Math.round(cx+x),Math.round(cy-y));
plot(Math.round(cx-x),Math.round(cy-y));
y--;
py-=twoRx2;
if(p>0){
p+=rx2-py;
}else{
x++;
px+=twoRy2;
p+=rx2-py+px;
}
}
}
function drawStamp(cx,cy){
const col=eraser?BG:hexToRgbInt(colorPicker.value);
beginStroke();
const r=Math.floor(stampSize/2);
switch(stampShape){
case'circle':
for(let dy=-r;dy<=r;dy++){
for(let dx=-r;dx<=r;dx++){
if(dx*dx+dy*dy<=r*r){
paintCell(cx+dx,cy+dy,col);
}
}
}
break;
case'square':
for(let dy=-r;dy<=r;dy++){
for(let dx=-r;dx<=r;dx++){
paintCell(cx+dx,cy+dy,col);
}
}
break;
case'triangle':
for(let dy=-r;dy<=r;dy++){
const w=Math.floor((r+dy)*(r/(r+0.5)));
for(let dx=-w;dx<=w;dx++){
paintCell(cx+dx,cy+dy,col);
}
}
break;
case'star':
for(let i=0;i<5;i++){
const angle=(i*4*Math.PI)/5-Math.PI/2;
const x=Math.round(cx+Math.cos(angle)*r);
const y=Math.round(cy+Math.sin(angle)*r);
bresenhamLineCell(cx,cy,x,y,(px,py)=>paintCell(px,py,col));
}
break;
case'heart':
for(let dy=-r;dy<=r;dy++){
for(let dx=-r;dx<=r;dx++){
const x=dx/r;
const y=-dy/r;
if(Math.pow(x*x+y*y-1,3)-x*x*y*y*y<=0){
paintCell(cx+dx,cy+dy,col);
}
}
}
break;
case'diamond':
for(let dy=-r;dy<=r;dy++){
for(let dx=-r;dx<=r;dx++){
if(Math.abs(dx)+Math.abs(dy)<=r){
paintCell(cx+dx,cy+dy,col);
}
}
}
break;
case'cross':
for(let i=-r;i<=r;i++){
paintCell(cx+i,cy,col);
paintCell(cx,cy+i,col);
}
break;
case'spiral':
for(let a=0;a<Math.PI*4;a+=0.2){
const sr=a/(Math.PI*4)*r;
const x=Math.round(cx+Math.cos(a)*sr);
const y=Math.round(cy+Math.sin(a)*sr);
paintCell(x,y,col);
}
break;
}
endStroke();
drawAll();
activeTool='brush';
updateToolButtons();
}
function updateToolButtons(){
$$('.btn').forEach(b=>{
if(b.id==='fillBtn')b.classList.toggle('active',activeTool==='fill');
if(b.id==='pickBtn')b.classList.toggle('active',activeTool==='pick');
if(b.id==='lineBtn')b.classList.toggle('active',activeTool==='line');
if(b.id==='rectBtn')b.classList.toggle('active',activeTool==='rect');
if(b.id==='circleBtn')b.classList.toggle('active',activeTool==='circle');
});
}
gridSlider.addEventListener('input',()=>{
N=+gridSlider.value;
updateUI();
});
gridSlider.addEventListener('change',()=>{
newCanvas();
setupCanvases();
});
brushSlider.addEventListener('input',()=>{
brush=+brushSlider.value;
updateUI();
});
zoomSlider.addEventListener('input',()=>{
zoom=+zoomSlider.value/100;
updateUI();
canWrap.style.transform=`scale(${zoom})`;
});
colorPicker.addEventListener('input',()=>{
hexOut.textContent=colorPicker.value.toUpperCase();
if(eraser){
eraser=false;
setSwitch(erSw,eraser);
}
});
drawModeSelect.addEventListener('change',()=>{
drawMode=drawModeSelect.value;
vctx.clearRect(0,0,vectorCanvas.width,vectorCanvas.height);
sctx.clearRect(0,0,smoothCanvas.width,smoothCanvas.height);
drawGrid();
toast('Mode',drawMode);
});
rbSw.addEventListener('click',()=>{
rainbow=!rainbow;
setSwitch(rbSw,rainbow);
toast('Rainbow',rainbow?'ON':'OFF');
});
erSw.addEventListener('click',()=>{
eraser=!eraser;
setSwitch(erSw,eraser);
toast('Eraser',eraser?'ON':'OFF');
});
glSw.addEventListener('click',()=>{
showGrid=!showGrid;
setSwitch(glSw,showGrid);
drawGrid();
toast('Grid lines',showGrid?'ON':'OFF');
});
symSw.addEventListener('click',()=>{
symmetry=!symmetry;
setSwitch(symSw,symmetry);
toast('Symmetry',symmetry?'ON':'OFF');
});
symAxisSelect.addEventListener('change',()=>{
symAxis=symAxisSelect.value;
toast('Symmetry',symAxis);
});
newBtn.addEventListener('click',()=>{
if(confirm('New canvas?'))newCanvas();
});
undoBtn.addEventListener('click',doUndo);
redoBtn.addEventListener('click',doRedo);
clearBtn.addEventListener('click',()=>{
if(confirm('Clear layer?'))clearAll();
});
saveBtn.addEventListener('click',savePNG);
exportBtn.addEventListener('click',exportJSON);
importBtn.addEventListener('click',()=>fileIn.click());
fileIn.addEventListener('change',()=>{
const f=fileIn.files&&fileIn.files[0];
if(f)importJSONFile(f);
fileIn.value='';
});
layerOpSlider.addEventListener('input',()=>{
layers[activeLayerIdx].opacity=+layerOpSlider.value/100;
updateUI();
drawAll();
});
blendModeSelect.addEventListener('change',()=>{
layers[activeLayerIdx].blend=blendModeSelect.value;
drawAll();
toast('Blend',blendModeSelect.value);
});
addLayerBtn.addEventListener('click',()=>{
const newLayer={
id:Date.now(),
name:`Layer ${layers.length+1}`,
pixels:new Uint32Array(N*N),
opacity:1,
visible:true,
blend:'normal'
};
newLayer.pixels.fill(BG);
layers.push(newLayer);
activeLayerIdx=layers.length-1;
updateLayerList();
updateUI();
drawAll();
toast('Layer',newLayer.name);
});
delLayerBtn.addEventListener('click',()=>{
if(layers.length<=1){
toast('Layer','Cannot delete last layer');
return;
}
if(confirm(`Delete ${layers[activeLayerIdx].name}?`)){
layers.splice(activeLayerIdx,1);
activeLayerIdx=Math.max(0,activeLayerIdx-1);
updateLayerList();
updateUI();
drawAll();
toast('Deleted','Layer removed');
}
});
mergeLayerBtn.addEventListener('click',()=>{
if(activeLayerIdx===0){
toast('Merge','No layer below');
return;
}
const upper=layers[activeLayerIdx];
const lower=layers[activeLayerIdx-1];
for(let i=0;i<N*N;i++){
if(upper.pixels[i]!==BG){
lower.pixels[i]=upper.pixels[i];
}
}
layers.splice(activeLayerIdx,1);
activeLayerIdx--;
updateLayerList();
updateUI();
drawAll();
toast('Merged','Layers combined');
});
function updateLayerList(){
layerListEl.innerHTML='';
for(let i=layers.length-1;i>=0;i--){
const layer=layers[i];
const item=document.createElement('div');
item.className='layerItem';
if(i===activeLayerIdx)item.classList.add('active');
const name=document.createElement('div');
name.className='layerName';
name.textContent=layer.name;
const controls=document.createElement('div');
controls.className='layerControls';
const visBtn=document.createElement('div');
visBtn.className='layerBtn';
visBtn.textContent=layer.visible?'👁':'👁‍🗨';
visBtn.addEventListener('click',(e)=>{
e.stopPropagation();
layer.visible=!layer.visible;
updateLayerList();
drawAll();
});
controls.appendChild(visBtn);
item.appendChild(name);
item.appendChild(controls);
item.addEventListener('click',()=>{
activeLayerIdx=i;
updateLayerList();
updateUI();
});
layerListEl.appendChild(item);
}
}
updateLayerList();
fpsSlider.addEventListener('input',()=>{
fps=+fpsSlider.value;
updateUI();
});
addFrameBtn.addEventListener('click',()=>{
const newFrame={
id:Date.now(),
layers:JSON.parse(JSON.stringify(layers.map(l=>({
id:l.id,
name:l.name,
pixels:Array.from(l.pixels),
opacity:l.opacity,
visible:l.visible,
blend:l.blend
}))))
};
frames.splice(activeFrameIdx+1,0,newFrame);
activeFrameIdx++;
updateFrameList();
updateUI();
toast('Frame',`Added frame ${activeFrameIdx+1}`);
});
delFrameBtn.addEventListener('click',()=>{
if(frames.length<=1){
toast('Frame','Cannot delete last frame');
return;
}
if(confirm(`Delete frame ${activeFrameIdx+1}?`)){
frames.splice(activeFrameIdx,1);
activeFrameIdx=Math.max(0,activeFrameIdx-1);
loadFrame(activeFrameIdx);
updateFrameList();
updateUI();
toast('Deleted',`Frame removed`);
}
});
dupFrameBtn.addEventListener('click',()=>{
const dupFrame={
id:Date.now(),
layers:JSON.parse(JSON.stringify(layers.map(l=>({
id:l.id,
name:l.name,
pixels:Array.from(l.pixels),
opacity:l.opacity,
visible:l.visible,
blend:l.blend
}))))
};
frames.splice(activeFrameIdx+1,0,dupFrame);
activeFrameIdx++;
updateFrameList();
updateUI();
toast('Frame',`Duplicated to ${activeFrameIdx+1}`);
});
playBtn.addEventListener('click',()=>{
if(animPlaying)return;
animPlaying=true;
let frameIdx=0;
const play=()=>{
if(!animPlaying)return;
loadFrame(frameIdx);
drawAll();
frameIdx=(frameIdx+1)%frames.length;
animTimer=setTimeout(play,1000/fps);
};
play();
toast('Play','Animation playing');
});
stopBtn.addEventListener('click',()=>{
animPlaying=false;
clearTimeout(animTimer);
toast('Stop','Animation stopped');
});
function loadFrame(idx){
activeFrameIdx=idx;
layers=frames[idx].layers.map(l=>({
id:l.id,
name:l.name,
pixels:new Uint32Array(l.pixels),
opacity:l.opacity,
visible:l.visible,
blend:l.blend
}));
activeLayerIdx=Math.min(activeLayerIdx,layers.length-1);
updateLayerList();
updateFrameList();
updateUI();
drawAll();
}
function saveFrame(){
frames[activeFrameIdx].layers=JSON.parse(JSON.stringify(layers.map(l=>({
id:l.id,
name:l.name,
pixels:Array.from(l.pixels),
opacity:l.opacity,
visible:l.visible,
blend:l.blend
}))));
}
function updateFrameList(){
frameListEl.innerHTML='';
frames.forEach((frame,idx)=>{
const thumb=document.createElement('div');
thumb.className='frameThumb';
if(idx===activeFrameIdx)thumb.classList.add('active');
const mini=document.createElement('canvas');
mini.width=60;
mini.height=60;
const mctx=mini.getContext('2d',{alpha:false});
mctx.fillStyle='#0b0f17';
mctx.fillRect(0,0,60,60);
const cs=60/N;
frame.layers.forEach(layer=>{
if(!layer.visible)return;
mctx.globalAlpha=layer.opacity;
for(let y=0;y<N;y++){
for(let x=0;x<N;x++){
const i=y*N+x;
const col=layer.pixels[i];
if(col===BG)continue;
mctx.fillStyle='#'+(col>>>0).toString(16).padStart(6,'0');
mctx.fillRect(x*cs,y*cs,cs,cs);
}
}
});
mctx.globalAlpha=1;
thumb.appendChild(mini);
const num=document.createElement('div');
num.className='frameNum';
num.textContent=String(idx+1);
thumb.appendChild(num);
thumb.addEventListener('click',()=>{
saveFrame();
loadFrame(idx);
});
frameListEl.appendChild(thumb);
});
}
updateFrameList();
exportAnimBtn.addEventListener('click',async()=>{
exportModal.classList.add('show');
exportStatus.textContent='Rendering frames...';
exportProgress.style.width='0%';
const zip=[];
for(let i=0;i<frames.length;i++){
const frame=frames[i];
const cellPx=20;
const outSize=N*cellPx;
const off=document.createElement('canvas');
off.width=outSize;
off.height=outSize;
const o=off.getContext('2d',{alpha:false});
o.fillStyle='#'+BG.toString(16).padStart(6,'0');
o.fillRect(0,0,outSize,outSize);
frame.layers.forEach(layer=>{
if(!layer.visible)return;
o.globalAlpha=layer.opacity;
o.globalCompositeOperation=layer.blend==='normal'?'source-over':layer.blend;
for(let y=0;y<N;y++){
for(let x=0;x<N;x++){
const idx=y*N+x;
const col=layer.pixels[idx];
if(col===BG)continue;
o.fillStyle='#'+(col>>>0).toString(16).padStart(6,'0');
o.fillRect(x*cellPx,y*cellPx,cellPx,cellPx);
}
}
});
o.globalAlpha=1;
o.globalCompositeOperation='source-over';
const url=off.toDataURL('image/png');
zip.push({name:`frame_${String(i+1).padStart(3,'0')}.png`,url});
exportProgress.style.width=`${((i+1)/frames.length)*100}%`;
await new Promise(r=>setTimeout(r,10));
}
exportStatus.textContent='Downloading frames...';
for(const item of zip){
const a=document.createElement('a');
a.href=item.url;
a.download=item.name;
a.click();
await new Promise(r=>setTimeout(r,100));
}
exportStatus.textContent='Export complete!';
setTimeout(()=>exportModal.classList.remove('show'),1500);
toast('Export',`${frames.length} frames`);
});
closeExportModal.addEventListener('click',()=>{
exportModal.classList.remove('show');
});
genPaletteBtn.addEventListener('click',()=>{
const type=paletteTypeSelect.value;
const base=hexToRgbInt(colorPicker.value);
const{h,s,l}=rgbToHsl((base>>16)&0xFF,(base>>8)&0xFF,base&0xFF);
palette=[];
if(type==='analogous'){
for(let i=-2;i<=2;i++){
palette.push(rgbIntToHex(hslToRgbInt((h+i*30+360)%360,s,l)));
}
}else if(type==='complementary'){
palette.push(rgbIntToHex(base));
palette.push(rgbIntToHex(hslToRgbInt((h+180)%360,s,l)));
palette.push(rgbIntToHex(hslToRgbInt((h+30)%360,s,l)));
palette.push(rgbIntToHex(hslToRgbInt((h+210)%360,s,l)));
palette.push(rgbIntToHex(hslToRgbInt((h+330)%360,s,l)));
}else if(type==='triadic'){
palette.push(rgbIntToHex(base));
palette.push(rgbIntToHex(hslToRgbInt((h+120)%360,s,l)));
palette.push(rgbIntToHex(hslToRgbInt((h+240)%360,s,l)));
palette.push(rgbIntToHex(hslToRgbInt((h+60)%360,s,l)));
palette.push(rgbIntToHex(hslToRgbInt((h+180)%360,s,l)));
}else if(type==='monochrome'){
for(let i=0;i<5;i++){
const nl=0.2+i*0.15;
palette.push(rgbIntToHex(hslToRgbInt(h,s,nl)));
}
}else{
for(let i=0;i<10;i++){
const rh=Math.random()*360;
const rs=0.6+Math.random()*0.4;
const rl=0.4+Math.random()*0.3;
palette.push(rgbIntToHex(hslToRgbInt(rh,rs,rl)));
}
}
while(palette.length<10){
palette.push('#'+Math.floor(Math.random()*16777215).toString(16).padStart(6,'0'));
}
updatePaletteGrid();
toast('Palette',type);
});
extractPaletteBtn.addEventListener('click',()=>{
const colors=new Set();
layers.forEach(layer=>{
for(let i=0;i<layer.pixels.length;i++){
const col=layer.pixels[i];
if(col!==BG)colors.add(col);
}
});
palette=Array.from(colors).slice(0,10).map(c=>rgbIntToHex(c));
while(palette.length<10){
palette.push('#'+Math.floor(Math.random()*16777215).toString(16).padStart(6,'0'));
}
updatePaletteGrid();
toast('Extract',`${colors.size} colors found`);
});
savePaletteBtn.addEventListener('click',()=>{
localStorage.setItem('mcs_palette',JSON.stringify(palette));
toast('Palette','Saved to browser');
});
function updatePaletteGrid(){
paletteGridEl.innerHTML='';
palette.forEach(col=>{
const item=document.createElement('div');
item.className='paletteItem';
item.style.background=col;
item.addEventListener('click',()=>{
colorPicker.value=col;
hexOut.textContent=col.toUpperCase();
toast('Color',col);
});
paletteGridEl.appendChild(item);
});
}
const savedPalette=localStorage.getItem('mcs_palette');
if(savedPalette){
try{
palette=JSON.parse(savedPalette);
}catch(e){}
}
updatePaletteGrid();
glowBtn.addEventListener('click',()=>{
applyGlow();
toast('Effect','Glow applied');
});
blurBtn.addEventListener('click',()=>{
applyBlur();
toast('Effect','Blur applied');
});
pixelateBtn.addEventListener('click',()=>{
applyPixelate();
toast('Effect','Pixelate applied');
});
invertBtn.addEventListener('click',()=>{
applyInvert();
toast('Effect','Invert');
});
grayscaleBtn.addEventListener('click',()=>{
applyGrayscale();
toast('Effect','Grayscale');
});
sepiaBtn.addEventListener('click',()=>{
applySepia();
toast('Effect','Sepia');
});
brightSlider.addEventListener('input',()=>{
effectState.brightness=+brightSlider.value;
updateUI();
});
contrastSlider.addEventListener('input',()=>{
effectState.contrast=+contrastSlider.value;
updateUI();
});
satSlider.addEventListener('input',()=>{
effectState.saturation=+satSlider.value;
updateUI();
});
applyEffectBtn.addEventListener('click',()=>{
tempEffectCanvas=null;
drawAll();
toast('Apply','Effect committed');
});
resetEffectBtn.addEventListener('click',()=>{
effectState={brightness:100,contrast:100,saturation:100};
brightSlider.value='100';
contrastSlider.value='100';
satSlider.value='100';
updateUI();
tempEffectCanvas=null;
drawAll();
toast('Reset','Effects cleared');
});
function applyGlow(){
const layer=layers[activeLayerIdx];
begin
